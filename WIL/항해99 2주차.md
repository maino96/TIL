알고리즘  과제 및 테스트
 

기간 : 2022. 09. 23 (금) ~ 2022. 09. 29 (목) 

 : 알고리즘

 

1. 팀 배정 
F반 4조 

팀원 : 박민호, 이승표, 김은서

 

항해99 1주차 미니 프로젝트가 끝나자마자 바로 2추자 알고리즘에 관하여 마라톤 과제가 주어졌고,

9월 27일에는 알고리즘 모의고사, 29일에는 알고리즘 테스트가 진행 되었다.

우선은 시작하는 23일까지 언어에 관해 과제를 학습하고 제출하는거였다.

팀원분들끼리 강의를 듣고 서로 물어보면서 과제를 제출하기로 하였고, 언어 과제에 관해서는 

그렇게 막 어렵고 복잡하지 않았던거같다. 

과제를 제출하고 드디어 마라톤 알고리즘 문제를 풀러갔다.

 


 

대략 이런 느낌으로, 말 뜻대로 알고리즘 '마라톤' 다웠다..

예상과는 달리 첫 문제부터 이해가 안되고 접근하기가 어려웠다.

지금 생각해보면, 자바스크립트에 관해 조금 더 친숙해지라는 항해99의 목표였던거같다. 

막히는 문제가 생기면 구글링을 통해 기본 문법을 다시 복습? 하면서 개념 정리를 하였고,

그래도 막힌다면 팀원분들에게 조언을 구했다.

서로 서로 각자 푼 방식에 대해 설명을 하고 도움을 주다보니

'와 이런방식으로도 풀 수 있구나'  라는 생각이 정말정말 한 주 내내 들었다.

어느새 적응이 되어버린 나는.. 서서히 문제를 풀어나갔다.

솔직히말하면 28 문제 풀면서 너무 힘들고 지쳤다. 한 문제씩 거의 2시간은 걸렸었고 머리가 너무 아프고 

무엇보다 지겨웠다. 하지만 다양한 접근방식과 이해도가 남다르게 성장한것을 느꼈고 포기하고싶지 않았다.

그 작은곳에서 재미를 찾으려고 노력했었다.

 

알고리즘 테스트는 너무 어려웠다. 문제들에 함정들이 존재했고, 2번문제는 속아버렸다.. 크크..

하지만 이 또한 경험이라고 생각한다. 문제가 조금이라도 바뀐다면 접근방식이 아예 달라져버린다.

 

 

 

이번 4조는 말 그대로 정말 팀 다웠다. 다들 너무 착하시고 좋으신 분들이였다.

너무 많은 도움을 받았고 또 만나고 싶은 팀이기도했다.

 

 

 

 

2.  자바스크립트의 ES란?
ES 는 무엇인가
ES 는 ECMAScript 의 약자입니다. 그리고 숫자 6은 여섯번째 ES 라고 생각하면 되겠습니다. 그렇다면 ES, ECMAScript 는 무엇일까요?

위키백과를 보면 ECMAScript 는 Ecma 인터내셔널의 ECMA-262 기술 규격에 정의된 표준화된 스크립트 프로그래밍 언어입니다. 자바스크립트를 표준화하기 위해서 만들어졌으며 꼭 자바스크립트가 아니더라도 어도비 플래시를 사용하는 소프트웨어에서 사용하는 액션스크립트, MS 사의 인터넷 익스플로러에 쓰이는 J스크립트 등 다른 구현체들 역시 포함하고 있습니다.

 

ES 가 등장하게 된 배경을 살펴보면 1990년대로 거슬러 올라갑니다. Netscape 회사는 웹 디자이너들과 파트타입 프로그래머들이 이미지, 플러그인 등의 요소를 쉽게 조합해줄 언어를 필요로 하게 되었고 이를 위해 Brendan Eich 를 영입하게 됩니다. Brendan Eich 는 모카라는 새로운 언어를 만들고 이 이름은 라이브스크립트로 다시 자바스크립트로 이름을 바꾸게 됩니다. 이름을 지은데에는 이 언어가 자바 언어에서 파생되었다는 마케팅적인 이유가 있다고 생각하고 있습니다.

 

자바스크립트가 성공하자 경쟁사인 MS 는 이를 견제하기 위해 J스크립트를 개발하게 됩니다. 당시 웹브라우저에서 압도적인 점유율을 차지하던 IE 에서 J스크립트를 지원하기 시작하자 두 비슷한 스크립트 언어가 사람들에게 혼란을 야기하게 됩니다. 따라서 이 둘 뿐 아니라 여러 스크립트 언어들에 대한 표준이 필요하다고 생각했고 ES 가 등장하게 되었습니다.

 

따라서 ES 는 프로그래밍 언어가 아닌 스크립트 언어들에 대한 표준, 규격입니다.

 

 

 

 

왜 ES6 인가
그렇다면 우리는 왜 ES6 에 대해 큰 관심을 가지는 것일까요?

ES6가 최신 버전이기 때문에 그럴까요?

아닙니다. 현재 2019년 12월 기준으로 ES10 까지 나왔습니다. 1997년 6월에 1판을 시작으로 불규칙적이게 개정되던 것이 2015년 부터는 매년 6월에 규칙적으로 개정이 되고 있습니다.

판출판일이름이전 판과의 차이점

1	1997/6	 	초판
2	1998/6	 	ISO/IEC 16262 국제 표준과 완전히 동일한 규격을 적용하기 위한 변경.
3	1999/12	 	강력한 정규 표현식, 향상된 문자열 처리, 새로운 제어문 , try/catch 예외 처리, 엄격한 오류 정의, 수치형 출력의 포매팅 등.
4	버려짐	 	4번째 판은 언어에 얽힌 정치적 차이로 인해 버려졌다. 이 판을 작업 가운데 일부는 5번째 판을 이루는 기본이 되고 다른 일부는 ECMA스크립트의 기본을 이루고 있다.
5	2009/12	 	더 철저한 오류 검사를 제공하고 오류 경향이 있는 구조를 피하는 하부집합인 "strict mode"를 추가한다. 3번째 판의 규격에 있던 수많은 애매한 부분을 명확히 한다.[3]
5.1	2011/6	 	ECMA스크립트 표준의 제 5.1판은 ISO/IEC 16262:2011 국제 표준 제3판과 함께 한다.
6	2015/6	ES2015	6판에는 클래스와 모듈 같은 복잡한 응용 프로그램을 작성하기 위한 새로운 문법이 추가되었다. 하지만 이러한 문법의 의미는 5판의 strict mode와 같은 방법으로 정의된다. 이 판은 "ECMAScript Harmony" 혹은 "ES6 Harmony" 등으로 불리기도 한다.
7	2016/6	ES2016	제곱연산자 추가, Array.prototype.includes
8	2017/ 6	ES2017	함수 표현식의 인자에서 trailing commas 허용, Object values/entries 메소드, async/await 등.
9	2018/6	ES2018	Promise.finally, Async iteration, object rest/spread property 등.
10	2019/6	ES2019	Object.fromEntries, flat, flatMap, Symbol.description, optional catch 등.
 

특히 이 중 ES6 에서는 ES5 이하 명세에서 문제가 되었던 부분들이 해결되었고 많은 기능들이 추가되었습니다. 이는 가독성과 유지보수성 향상으로 이어졌습니다. React 나 Vue 등 유명 라이브러리들도 이에 맞춰 개발 환경을 ES6로 바꾸게 되었습니다.

이러한 이유로 인해 우리는 ES6에 주목하고 관심을 갖게 되었습니다.

 

3. ES5와 ES6의 차이
 

ES5와 ES6의 대표적인 차이점으로 아래 항목들을 들 수 있다.

템플릿 리터럴
화살표 함수
this
변수선언
모듈
클래스
템플릿 리터럴
ES6부터 새롭게 등장한 템플릿 리터럴. 덕분에 문자열 표현이 훨씬 간단해졌다.
템플릿 리터럴이란 작은 따옴표나 큰 따옴표 대신 백틱(`)으로 문자열을 감싸 표현하는 기능을 말한다.
템플릿 리터럴을 사용하면 플레이스 홀더(${variable})를 사용하여 백틱 내부에 문자열과 함께 표현식을 넣을 수 있다.

 

ES5

copy javascriptvar name = "현진";
var age = 25;
console.log("저의 이름은 " + name + "이고, 나이는 " + age + "살 입니다.");
ES6

copy javascriptvar name = "현진";
var age = 25;
console.log(`저의 이름은 ${name}이고, 나이는 ${age}살 입니다.`);
화살표 함수
ES6부터 새롭게 등장한 화살표 함수로 함수 선언법이 좀 더 간단해졌다.

 

ES5

함수 선언식

copy javascriptfunction str(arg1, arg2) { console.log("용민"); }
생성자 함수(많이 사용하지 않음)

copy phpvar str = new Function("arg1", "arg2", "console.log('용민')");
함수 리터럴(익명 함수를 만들 때 사용)

copy javascriptvar str = function(arg1, arg2) { console.log("용민"); };
🚀 참고
여기서 익명 함수란 말 그대로 이름이 없는 함수를 뜻한다.
ex) var bar = function (a, b) {...};
반대로 기명 함수는 이름이 있는 함수이다.
ex) var bar = function funcName(a, b) {...}

 

ES6

copy coffeescriptvar str = (arg1, arg2) => {
  console.log("용민");
};
copy javascriptvar str = arg1 => console.log(arg1);
화살표 함수에 인자(argument)가 하나밖에 없다면 괄호를 생략할 수 있다.
또한 한줄로 표현이 가능하다면 위와 같이 중괄호({})를 생략할 수 있다.

copy swiftvar str = func => ({ id: "31" });
화살표 함수가 객체를 반환한다면 위와같이 표현해줄 수 있다.

this의 다른 동작
ES5

ES5같은 경우 객체 내에 있는 메소드를 실행 시 this는 메소드가 선언된 해당 객체를 가리킨다.
하지만 객체 안에서 선언된 함수의 this는 해당 객체가 아닌 window를 바라보고 있기 때문에 함수 안에서 this.name, this.age 를 하여도 아무 값이 나오지 않는다.


이러한 경우 해결방안으로 innerInfo.call(this) 를 통해 this 를 바인딩 시켜주거나 this를 해당 변수에 담아서 var self = this 와 같은 방식으로 접근하면 사용하면 된다.

copy javascriptvar thisTest = {
     name : "김현진",   
     age : 25,
     info : function() {
          console.log(this)
          console.log(this.name , this.age)

          function innerInfo() {
              console.log(this)
              return this.name + ":" + this.age
          }
          return innerInfo()
     }
}

// 실행결과 
// {name: "김현진", age: 25, info: ƒ}
// 김현진 25
// Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}
// ":undefined"
ES6

ES6에서의 this 는 자신을 둘러싸고 있는 this를 바라보기 때문에 따로 바인딩이나 변수에 담을 필요 없다.

copy kotlinlet thisTest = {
     name : "김현진",   
     age : 25,
     info() {
          console.log(this)
          console.log(this.name , this.age)

          innerInfo = () => {
              console.log(this)
              return this.name + ":" + this.age
          }
          return innerInfo()
     }
}

// 실행결과
// {name: "김현진", age: 25, info: ƒ}
// 김현진 25
// {name: "김현진", age: 25, info: ƒ}
// "김현진:25"
생성자 함수의 인스턴스의 경우, this는 인스턴스를 가리킨다.

copy csfunction Obj(value) {
  this.value = value;
}
var obj = new Obj(0);
console.log(obj.value); // 0
화살표 함수를 쓰면 함수가 선언된 스코프에 자동 바인딩이 된다.

copy javascriptvar obj = {
  value: 10,

  // 메소드 호출
  show: function () {
    console.log(this.value); // 10

    // 함수 호출
    function show_01 () {
      console.log(this.value); // undefined
    }
    show_01();

    // 화살표 함수
    function show_02 = () => {
      console.log(this.value); // 10
    }
    show_02();
  }
}
obj.show();
변수 선언
ES5

ES5에선 var 밖에 존재하지 않았다. var 는 변수를 선언할 때 사용되는 키워드로,
재할당과 재선언에 굉장히 자유롭다.

copy javascriptvar x = 10;
x = 15;
console.log(x); //15
var x = 12;
console.log(x); //12
ES6

ES6부터 let, const가 추가되었다.

let은 한번 선언된 변수에 동일한 이름으로 선언할 수 없다.
하지만, 값은 재할당 할 수 있다.

copy javascriptlet x = 10;
x = 15;
console.log(x); //15
let x = 12; // Identifier 'x' has already been declared
const는 한번 초기화된 변수에 재할당/재선언할 수 없다.

copy cppconst x = 10;
console.log(x); // 10;
x = 15; // TypeError: Assignment to constant variable.
그리고, let, const는 블록 스코프 또는 Function 스코프 내부에 선언되면 해당 스코프 밖에서 안에 있는 변수를 참조할 수 없다.

쉽게 설명하자면, 중괄호로 묶인 부분 내부에 선언된 let, const를 중괄호 외부에서 참조할 수 없다는 것이다.

copy javascriptif (true) {
  var i = 0;
}
console.log(i); // 0
if (true) {
  let j = 10;
}
console.log(j); // ReferenceError
if (true) {
  const k = 100;
}
console.log(k); // ReferenceError
밖에서 안에 있는 const, let은 참조할 수는 있다.

copy cppconst i = 5;
if (ture) {
  console.log(i); // 5
}
var는 Function 스코프는 내부에 선언된 var를 외부에서 참조할 수 없지만

블록 스코프에선 내부에 선언되어 있어도 외부에서 참조 가능하다.

copy javascriptfunction f() {
  var v = 5;

  console.log(v); // 5
}

console.log(v); // ReferenceError: v is not defined

if (true) { 
    var i = 0;
}

console.log(i); // 0
정리하자면 다음과 같다.

 	재 선언	재 할당	Block scope	Function scope
var	O	O	외부에서 내부 참조 가능	외부에서 내부 참조 불가
let	X	O	외부에서 내부 참조 불가	외부에서 내부 참조 불가
const	X	X	외부에서 내부 참조 불가	외부에서 내부 참조 불가
모듈
ES5 이전에는 각 기능별로 JS 파일을 나누고 개발 및 관리하는 것이 불가능했다.

 

ES5

ES5 에선 require 를 통해 모듈화를 할 수 있었다.

예를 들어 아래와 같은 구조인 경우,

copy luajs / - - -script.js
      |
      ---  slider.js
copy xml<script>
  src = "slider.js";
</script>
<script>
  src = "script.js";
</script>
index.html

copy javascriptvar slider = require(./slider.js)
// 혹은 require(./slider)
script.js

 

위와 같이 함으로써, slider.js를 임포트할 수 있었다. 이러한 방법으로 파일 자체를 사용할 수 있다.

 

ES6

ES6 부터는 import/export 로 모듈을 관리할 수 있다.
모듈은 실현가능한 특정 프로그램의 그룹니다.
그리고 이것은 다른 파일의 변수, 함수를 참조한다.
클래스와 같은 모듈이 로딩될 때, import와 export를 이용해 사용될 수 있다.

 

하나의 모듈만 공유할 때

로드 모듈

copy coffeescriptimport 'import to loadname' from '파일 경로'
아웃풋 모듈

copy coffeescriptexport default 'module'
copy coffeescriptimport Carousel from "./carousel";
cosnt carousel = new Carousel();
script.js

copy javascriptexport default class Carousel {
    constructor() {
        this.calc();
    }
    calc() {
        console.log(10);
    }
}
carousel.js

 

여러 모듈을 사용할 때

아웃풋 관점에서, export는 사용하고 싶은 곳에 붙이고, import는 다음과 같이 사용하면 된다.

copy coffeescriptimport {a1, a2, ...} from '파일 경로'}
copy javascriptimport { multi, SuperMulti } from "./Multiplay";
console.log(multi(5)); // 50
console.log(SuperMulti(6)); // 600
script.js

copy javascriptexport const i = 10;

export function multi(x) {
  return i * x;
}

export function superMulti(x) {
  return i * x * 10;
}
만약 모등 모듈을 전달받기 위해서는 import를 아래와 같이 작성하면 된다.

copy kotlinimport * as ‘object name’ form ‘파일 경로’
copy javascriptimport * as lib from "./multiply";
console.log(lib.multi(5)); // 50
클래스
ES5

ES5에선 class라는 키워드는 없었지만 프로토타입을 통해 실현 가능했다.

copy javascriptvar Add = function(arg1, arg2) {
  this.arg1 = arg1;
  this.arg2 = arg2;
};

Add.prototype.calc = function() {
  return this.arg1 + "+" + this.arg2 + "=" + (this.arg1 + this.arg2);
};

var num = new Add(5, 8);
console.log(num.calc()); // 5 + 8 = 13
ES6

ES6에서는 class 키워드를 사용해서 선언할 수 있다.

copy kotlinclass Add {
  constructor(arg1, arg2) {
    this.arg1 = arg1;
    this.arg2 = arg2;
  }
  calc() {
    return this.arg1 + "+" + this.arg2 + "=" + (this.arg1 + this.arg2);
  }
}

var num = new Add(5, 8);
console.log(num.calc()); // 5 + 8 = 13
클래스 상속
클래스의 상속과 오버라이딩은 super를 사용해서 수행할 수 있다.

 

ES5

copy javascriptvar AddSquare = function(arg1, arg2) {
  Add.call(this, arg1, arg2);
};

Object.assign(AddSquare.prototype, Add.prototype);

AddSquare.prototype = {
  calc: function() {
    // 메소드는 생략될 수 없습니다.
    Add.prototype.calc.call(this);
  },
  calcSquare: function() {
    this.pow = Math.pow(this.arg1 + this.arg2, 2);
    return "(" + this.arg1 + "+" + this.arg2 + ")^2=" + this.pow;
  }
};

var numSquare = new AddSquare(5, 8);
console.log(numSquare.calc()); // 5 + 8 = 13
console.log(numSquare.calcSquare()); // (5 + 8) ^ 2 =169
ES6

copy scalaclass AddSquare extends Add {
  constructor(arg1, arg2) {
    super(arg1, arg2);
  }
  calc() {
    super.calc();
  }
  calcSquare() {
    this.pow = Math.pow(this.arg1 + this.arg2, 2);
    return "(" + this.arg1 + "+" + this.arg2 + ") ^ 2 =" + this.pow;
  }
}

var numSquare = new AddSquare(5, 8);
console.log(numSquare.calc()); // 5 + 8 = 13
console.log(numSquare.calcSquare()); // (5 + 8) ^ 2 = 169
 

출처

https://juniordev-team.tistory.com/6