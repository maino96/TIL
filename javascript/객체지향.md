---

## 01. 객체 지향 (Object-Oriented)

[3.3-1-1 7분 30초경 VS 수정 필요_exported.mp4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e332bef5-b355-4847-b093-7d8474528d53/3.3-1-1_7%E1%84%87%E1%85%AE%E1%86%AB_30%E1%84%8E%E1%85%A9%E1%84%80%E1%85%A7%E1%86%BC_VS_%E1%84%89%E1%85%AE%E1%84%8C%E1%85%A5%E1%86%BC_%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD_exported.mp4)

- 1) 객체 지향이란?
    
    <aside>
    💡 **객체 지향**은 소프트웨어의 핵심을 **기능**이 아닌 **객체**로 삼으며 “**누가 어떠한 일을 할 것인가?**”에 초점을 맞춥니다.
    
    즉, **객체를 도출**하고 각각의 **역할을 정의**하는 것에 **초점**을 맞춥니다.
    
    </aside>
    
    - **책임**과 **권한**을 가진 **객체**들이 서로 메시지를 주고받으며 **협력**해서 필요한 **기능을 수행**하도록 시스템을 개발하는 것을 **객체 지향**이라고 합니다.
    - 크고 복잡한 시스템을 **효과적으로 분해**하고 **구성**할 수 있고, **손쉽게 이해**하고 **효율적으로 다룰 수 있게** 도와주는 방법으로 인정받아 많은 프로그래밍 언어에 적용되어 왔고 지금은 가장 인기 있는 프로그래밍 패러다임으로 자리 잡습니다.
    
    그렇다면 **객체 지향적인 소프트웨어**는 어떻게 구분할 수 있을까요?
    
    **절차지향**적인 소프트웨어와 **객체지향**적인 소프트웨어를 구분하는 방법은 아래의 기준을 만족할 경우 **객체지향**, 만족하지 않으면 **절차지향**적인 성격을 가집니다.
    
    - **캡슐화**, **다형성**, **클래스 상속**을 지원하는가?
    - **데이터 접근 제한**을 걸 수 있는가?
    
    여기서 **캡슐화, 다형성, 상속**에 관해서는 아래에서 자세히 살펴보도록 하겠습니다! 😊
    
- 2) 캡슐화 (**Encapsulation**)
    
    <aside>
    💡 개념적이나 물리적으로 객체 내부의 **세부적인 사항**을 **감추는 것**을 **캡슐화**라고 부릅니다.
    
    즉, 캡슐화를 사용하는 가장 큰 이유는 **정보은닉**을 목적으로 합니다.
    
    </aside>
    
    - **정보은닉**은 객체에 대한 **중요한 정보**를 **외부**로 **노출시키지 않도록** 하기 위한 기법입니다.
    
    캡슐화의 목적은 **변경하기 쉬운 객체**를 만드는 것입니다. 캡슐화를 통해 객체 내부의 접근을 **제한**하면 객체와 객체 사이의 **결합도**를 낮출 수 있기 때문에 설계를 좀 더 **쉽게 변경**할 수 있게 됩니다.
    
    `Javascript` 클래스는 멤버 변수를 숨길 수 없습니다. 그래서 개발자들은 멤버 변수 앞에 `_`를 붙여 클래스 내부의 변수를 숨긴 것 “**처럼**" 표시하겠다는 규칙을 만들었습니다. 
    
    하지만 `Javascript`를 실행했을 때에는 클래스의 멤버 변수가 숨겨지지 않으니, 이번 예제는 `Typescript`로 확인해보도록 하겠습니다.
    
    ```jsx
    /** Encapsulation **/
    class User {
      private name: string;
      private age: number;
    
      setName(name: string) { // Private 속성을 가진 name 변수의 값을 변경합니다.
        this.name = name;
      }
      getName() { // Private 속성을 가진 name 변수의 값을 조회합니다.
        return this.name;
      }
      setAge(age: number) { // Private 속성을 가진 age 변수의 값을 변경합니다.
        this.age = age;
      }
      getAge() { // Private 속성을 가진 age 변수의 값을 조회합니다.
        return this.age;
      }
    }
    
    const user = new User(); // user 인스턴스 생성
    user.setName("이용우");
    user.setAge(28);
    console.log(user.getName()); // 이용우
    console.log(user.getAge()); // 28
    console.log(user.name); // Error: User클래스의 name 변수는 private로 설정되어 있어 바로 접근할 수 없습니다.
    ```
    
    `User` 클래스를 선언하고 내부에는 `name`, `age` 멤버 변수를 초기화 하였습니다.
    
    여기서는 특별하게 `Private`라는 **접근 제한자(Access modifier)**를 사용하고 있는데요, 인스턴스 내부에서만 해당 변수에 접근이 가능하도록 제한하는 문법 입니다. 기존에 `Javascript`에서는 존재하지 않았지만 `Typescript`에서 제공하는 문법입니다.
    
    **→ [접근 제한자에 대해 자세히 알고 싶다면 여기를 클릭하세요!](https://www.howdy-mj.me/typescript/access-modifiers/)**
    
    여기서 `User` 클래스의 `name`, `age` 멤버 변수는 클래스 외부에서는 어떠한 방법으로도 **직접 접근**을 할 수 없습니다. 오로지 `setter`만 변수를 변경할 수 있고, `getter`만 변수를 조회할 수 있게 되었습니다.
    
- 3) 상속 (**Inheritance**)
    
    <aside>
    💡 상속이란 이미 정의된 **상위** 클래스의 특징을 **하위** 클래스에서 물려받아 **코드의 중복을 제거**하고 **코드 재사용성을 증대**시킵니다.
    
    즉, 하나의 클래스가 가진 **특징(함수, 변수 및 데이터)**을 다른 클래스가 그대로 **물려 받는 것**을 말합니다.
    
    </aside>
    
    - 개별 클래스를 **상속 관계**로 묶음으로써 클래스 간의 **체계화된 구조를 파악**하기 쉬워집니다.
    - 데이터와 메소드를 변경할 때 상위에 있는 것만 수정하여 전체적으로 **일관성을 유지**할 수 있습니다.
    
    기존에 작성된 클래스를 물려 받아 재활용하여 사용하므로 객체지향 프로그래밍의 중요한 기능 중 하나입니다!
    
    ```jsx
    /** Inheritance **/
    class Mother { // Mother 부모 클래스
      constructor(name, age, tech) { // 부모 클래스 생성자
        this.name = name;
        this.age = age;
        this.tech = tech;
      }
      getTech(){ return this.tech; } // 부모 클래스 getTech 메서드
    }
    
    class Child extends Mother{ // Mother 클래스를 상속받은 Child 자식 클래스
      constructor(name, age, tech) { // 자식 클래스 생성자
        super(name, age, tech);
      }
    }
    
    const child = new Child("이용우", "28", "Node.js");
    console.log(child.name); // 이용우
    console.log(child.age); // 28
    console.log(child.getTech()); // 부모 클래스의 getTech 메서드 호출: Node.js
    ```
    
    `Mother` 부모 클래스를 상속받은 `Child` 자식 클래스에서 `name`, `age` 멤버 변수를 직접 접근하여 호출하고, `Mother` 부모 클래스에서 정의된 `getTech()` 메소드를 호출하여 `Child` 자식 클래스에서 사용할 수 있게 되었습니다.
    
- 4) 추상화 (**Abstraction**)
    
    <aside>
    💡 **객체에서 공통된 부분을 모아 상위 개념으로 새롭게 선언하는 것을 추상화라고 합니다.**
    
    즉, **불필요한 부분을 생략**하고 객체 속성 중 **공통적**이고 **중요한 것**에만 중점을 두어 **모델화** 하는 것입니다.
    
    </aside>
    
    - 추상화는 객체들의 **공통적인 특성**을 파악하여 **필요 없는 특성**을 **제거**하는 과정입니다.
    - 시스템을 구축하기 전에 시스템 구조 및 구성을 **가시적**으로 볼 수 있고, 해당 시스템과 유사한 모델을 만들어 여러가지 **테스트**를 할 수 있습니다.
    - 복잡한 내부 구현에 신경쓰지 않고, 외부에 노출되어 있는 인터페이스만을 이용하여 코드를 작성할 수 있습니다.
    
    클래스를 설계할 때 공통적으로 묶일 수 있는 기능을 **추상화** → **추상 클래스** → **인터페이스**로 모델링해서 향후 **다형성(Polymorphism)**으로 확장할 수 있도록 설계합니다.
    
    여기서 **인터페이스(`Interface`)**란 클래스 정의할 때 **메소드**와 **속성**만 **정의**하여 인터페이스에 선언된 프로퍼티 또는 메소드의 **구현을 강제**하여 코드의 **일관성을 유지**할 수 있도록 만듭니다.
    
    → [인터페이스에 대해 자세히 알고 싶다면 여기를 클릭하세요!](https://poiemaweb.com/typescript-interface)
    
    ```tsx
    /** Abstraction **/
    interface Human {
      name: string;
      setName(name);
      getName();
    }
    
    // 인터페이스에서 상속받은 프로퍼티와 메소드는 구현하지 않을 경우 에러가 발생합니다.
    class Employee implements Human {
      constructor(public name: string) {  }
      
      // Human 인터페이스에서 상속받은 메소드
      setName(name) { this.name = name; }
      
      // Human 인터페이스에서 상속받은 메소드
      getName() { return this.name; }
    }
    
    const employee = new Employee("");
    employee.setName("이용우"); // Employee 클래스의 name을 변경하는 setter
    console.log(employee.getName()); // Employee 클래스의 name을 조회하는 getter
    ```
    
    `Employee` 클래스는 `Human` 인터페이스에서 상속받은 `name` 멤버 변수와 `setName`, `getName` 추상 메소드를 강제로 구현하게 되었습니다.
    
    이제부터 **동일한 인터페이스**를 상속받은 **클래스**는 해당 인터페이스 내부에 선언되어 있는 **프로퍼티**와 **메소드**가 구현되어 있다는것을 인지할 수 있게 되었습니다.
    

[3.3-1-2_exported.mp4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/212018d0-25b7-45e5-90a2-8f6f8ae3e234/3.3-1-2_exported.mp4)

- 5) 다형성 (**Polymorphism**)
    
    <aside>
    💡 다형성이란 **객체(클래스)**가 **연산**을 수행하게 될 때 하나의 행위에 대해 각 객체가 가지고 있는 **고유한 특성**으로 **다른 여러 형태로 재구성 되는 것**을 말한다.
    
    즉, **동일한 메소드의 이름**을 사용하지만 메소드에 대해 **클래스마다** **다르게 구현되는 개념**이 다형성입니다.
    
    </aside>
    
    다형성을 통해 **역할**(인터페이스)과 **구현**을 분리해서 **오버라이딩(Overriding)**을 통해 서비스의 구현기능을 유연하게 변경, 확장이 가능합니다.
    
    **Java**의 **오버로딩(Overloading)**, **오버라이딩(Overriding)**가 대표적인 다형성의 예시입니다.
    
    → [오버로딩, 오버라이딩에 대해 자세히 알고 싶다면 여기를 클릭하세요!](http://www.tcpschool.com/java/java_inheritance_overriding)
    
    ```jsx
    /** Polymorphism **/
    class Employee {
      constructor(name) { this.name = name; }
    
      buy() { console.log(`${this.constructor.name} 클래스의 ${this.name}님이 물건을 구매하였습니다.`); }
    }
    
    class User {
      constructor(name) { this.name = name; }
    
      buy() { console.log(`${this.constructor.name} 클래스의 ${this.name}님이 물건을 구매하였습니다.`); }
    }
    
    const employee1 = new Employee("이용우");
    const employee2 = new Employee("김창환");
    const user1 = new User("이태강");
    const user2 = new User("김민수");
    
    const polymorphismArray = [employee1, employee2, user1, user2];
    // polymorphismArray에 저장되어 있는 Employee, User 인스턴스들의 buy 메소드를 호출합니다.
    polymorphismArray.forEach((polymorphism) => polymorphism.buy());
    
    // Employee 클래스의 이용우님이 물건을 구매하였습니다.
    // Employee 클래스의 김창환님이 물건을 구매하였습니다.
    // User 클래스의 이태강님이 물건을 구매하였습니다.
    // User 클래스의 김민수님이 물건을 구매하였습니다.
    ```
    
    `polymorphismArray.forEach()` 에서 `polymorphism`는 `Employee` 또는 `User` 클래스를 가리키고 있습니다.
    
    해당 반복문에서 매번 `buy` 메소드를 호출하는것은 동일하지만, `Employee`와 `User` 클래스에서 동작하는 `buy` 메소드는 다른 행위를 하고 있는 것을 확인할 수 있습니다! 😊
    
- 6) 의존성 (**Dependency**)
    
    <aside>
    💡 **의존성**이란 객체(모듈 및 클래스)들이 협력하는 과정 속에서 **해당 객체들이 다른 객체를 의존하게 되는 정도**를 나타냅니다.
    
    </aside>
    
    - 의존성이라는 말속에는 어떤 객체가 **변경**될 때 그 객체에 의존하는 다른 객체도 **함께 변경**될 수 있다는 사실이 내포되어 있습니다.
    - 만약 하나의 객체가 변경될 경우 의존하고 있는 다른 객체 또한 변경이 이루어지게 됩니다.
- 7) 결합도 (**Coupling**)
    
    <aside>
    💡 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 의존성을 가지고 있는지를 나타냅니다.
    
    </aside>
    
    - **객체** 사이의 **의존성이 과한 경우**를 가리켜 **결합도**가 **높다**고 말한다.
    - **객체**들이 **합리적인 수준으로 의존**할 경우에는 **결합도**가 **낮다**고 말한다.
    - **두 객체** 사이의 **결합도**가 높으면 높을수록 함께 **변경될 확률**도 높아지기 때문에 **변경하기 어려워진다.**
    - 따라서 설계의 목표는 **객체 사이**의 **결합도를 낮춰** **변경이 용이한 설계**를 만드는 것이어야 한다.
- 8) 응집도 (**Cohesion**)
    
    <aside>
    💡 응집도는 모듈에 포함된 **내부 요소**들이 각각 연관되어 있는 **관계**의 정도를 나타냅니다.
    
    </aside>
    
    - 밀접하게 **연관된 작업만을 수행**하고 연관성 없는 작업은 다른 객체에 **위임**하는 객체를 가리켜 **응집도가 높다고** 말한다.
    - 1개의 메소드가 내부에서 변수를 많이 사용할 수록 해당 **메소드**와 **클래스**는 **응집도**가 높아지게됩니다.
    - 자신의 데이터를 **스스로** 처리하는 **자율적인 객체**를 만들면 **결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.**
    - 객체의 응집도를 높이기 위해서는 객체는 스스로 **자신의 데이터를 책임**져야 합니다.
    

## 02. 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)

- 1) 프로그래밍 패러다임
    
    <aside>
    💡 **프로그래밍 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해줍니다.**
    
    </aside>
    
    **프로그래밍 패러다**임에는 대표적으로 3가지가 존재합니다.
    
    1. **구조적 프로그래밍 (Structured Programming)**
    2. **객체 지향 프로그래밍 (Object-Oriented Programming, OOP)**
    3. **함수형 프로그래밍 (Functional Programming)**
    
    **구조적 프로그래밍**은 **제어 흐름**의 **직접적인 전환**에 대한 규칙을 제시합니다.
    
    - **구조적 프로그래밍**은 **기능**을 중심적으로 개발을 진행합니다.
    - **구조적 프로그래밍**은 프로그래밍이라는 기술이 시작되면서 가장 처음으로 **적용**된 패러다임입니다.
    
    **객체 지향 프로그래밍**은 **제어흐름**의 **간접적인 전환**에 대한 규칙을 제시합니다.
    
    - **객체 지향 프로그래밍**은 프로그램의 처리단위가 **객체**인 프로그래밍 방법입니다.
    - **객체 지향 프로그래밍**은 “**현실 세계를 모델링**”하는 대표적인 프로그래밍 패러다임입니다.
    
    **함수형 프로그래밍**은 **할당문**에 대한 규칙을 제시합니다.
    
    - **함수형 프로그래밍**은 **함수**를 중심적으로 개발을 진행합니다.
    - **함수형 프로그래밍**은 3가지의 패러다임 중 가장 처음 만들어졌지만 최근들어 겨우 도입되기 시작하는 패러다임 입니다.
    
- 2) 객체 지향 프로그래밍 (Object-Oriented Programming, OOP)
    
    <aside>
    💡 **데이터**와 **프로세스**가 동일한 모듈 **내부**에 위치하도록 프로그래밍하는 방식을 **객체지향 프로그래밍(Object-Oriented Programming)**이라고 부릅니다.
    
    </aside>
    
    - **객체 지향 프로그래밍**은 **코드를 추상화**해 직관적으로 사고할 수 있기 때문에, **대표적인 프로그래밍 방법론**으로 적용되고 있습니다.
    - **객체 지향 프로그래밍**에서는 자동차, 동물, 사람 등과 같은 **현실 세계의 객체**를 유연하게 **표현**할 수 있습니다.
    - **객체**는 어떠한 **특성**을 가지고 있으며 특정 **기능을 수행**할 수 있습니다.
    - 자동차는 **객체**이고, 출발, 정지, 운행 및 제동과 같은 **기능**을 수행할 수 있습니다.
    
- 3) 왜 객체 지향 프로그래밍을 사용해야할까요?
    
    일반적으로 프로그래밍을 하다보면 단순히 **동작을 중심**으로 개발하는 것 보다 **데이터를 중심**으로 개발을 하게된다면 코드의 덩치가 커져도 **일관성을 유지하기 좋다**는것을 깨닫게 됩니다.
    
    만약 API를 만들 때 마다 **복사 → 붙여넣기** 방식으로 **동일한 코드를 여러군데 분산**을 시켜놓았을 때, 해당 로직을 수행하는 코드를 **수정**해야할 때 복사한 **모든 코드를 일일히 찾아가며 수정**을 해야하는 상황이 발생합니다. 
    
    우리는 프로그래밍을 하면서 **효율적으로 시간을 관리**할 수 있어야합니다. 그렇게 하기 위해선 코드를 얼마나 깔끔하게 짜느냐도 중요하지만, **코드 변경점**이 발생하더라도 최대한 코드를 **적게 수정**하여 **더욱 많은 시간**을 만들 수 있어야합니다. 
    
    발생한 문제 상황을 **빠르게 인지**하고, 어떤 코드에서 **오류**가 발생했는지 **빠르게 찾아보며**, 오류 사항을 **빠르게 고쳐** 개발에 사용하는 **시간을 최대한으로 줄이는것**을 **목표**로 삼아야합니다.
    
    **객체지향 프로그래밍**은 **데이터와 프로세스를 하나의 단위**로 처리하는 특성을 가지고 있기 때문에 코드를 수정해야할 때 어떤 코드에서 문제가 발생했는지 개발자들이 **직관적으로 인지**할 수 있으며 여러곳에 분산된 모든 코드를 수정해야하는 것이 아닌 **해당 로직을 수행하는 코드만 수정**하더라도 문제가 해결될 수 있습니다. 🙂
    
- 4) 객체지향 프로그래밍의 장점
    - **객체지향 프로그래밍**은 **의존성을 효율적으로 통제**할 수 있는 다양한 방법을 제공함으로써 **요구사항 변경에 좀 더 수월하게 대응**할 수 있는 가능성을 높여줍니다.
    - **동작**을 기준으로 프로그래밍을 진행하는 것보다 **데이터**를 중심으로 프로그래밍을 하게되면 코드의 덩치가 커지더라도 **일관성을 유지**하기 좋습니다.
    - 객체지향 코드는 **자신의 문제를 스스로 처리**해야 한다는 우리의 예상을 만족시켜주기 때문에 **이해하기 쉽고**, 객체 내부의 변경이 객체 외부에 파급되지 않도록 **제어**할 수 있기 때문에 **변경하기 수월합니다.**
    - 흔히 **데이터**와 **프로세스**를 **하나의 단위**로 통합해 놓는 방식으로 표현하기도 합니다.
    - **데이터**와 데이터를 사용하는 **프로세스**가 **동일한 객체** 안에 위치한다면 **객체지향 프로그래밍** 방식을 따르고 있을 확률이 높습니다.
    
- 5) 객체 지향 설계
    - **좋은 설계**란 **요구하는 기능**을 **온전히 수행**하면서 추후의 **변경을** **매끄럽게 수용**할 수 있는 설계입니다.
    - **변경 가능한 코드**란 **이해하기 쉬운 코드**입니다. 만약 코드를 변경해야 하는데 그 코드를 이해할 수 없다면 변경에 유용하더라도 코드를 수정하겠다는 마음이 선뜻 들지는 않을 것입니다.
    - **변경하기 쉬운 설계**는 한 번에 **하나의 클래스만 변경**할 수 있는 설계입니다.
    - 훌륭한 **객체지향 설계**의 핵심은 **캡슐화**를 이용해 **의존성**을 적절히 **관리**함으로써 객체 사이의 **결합도를 낮추는 것**이다.

## 03. 객체 지향 설계 5원칙

- 1) 객체 지향 설계 5원칙
    
    <aside>
    💡 **객체 지향 프로그래밍 및 설계**의 다섯가지 기본원칙을 **SOLID**라는 것으로 불리고 있습니다.
    
    </aside>
    
    - **SOLID**는 **객체 지향 프로그래밍 및 설계**의 다섯 가지 기본 원칙의 **맨 앞단어**를 하나씩 가져와 만든 것 입니다.
    - **SOLID**는 프로그래머가 시간이 지나도 **유지 보수**와 **확장**이 쉬운 시스템을 만들고자 할 때 사용합니다.
    
    **SOLID의 종류**
    
    - **단일 책임의 원칙 (Single Responsibility Principle, SRP)**
    - **개방-폐쇄 원칙 (Open-Closed Principle, OCP)**
    - **리스코프 치환 원칙 (Liskov substitution principle, LSP)**
    - **인터페이스 분리 원칙 (Interface segregation principle, ISP)**
    - **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**
- 2) 단일 책임의 원칙 (Single Responsibility Principle, **SRP**)
    
    **하나의 객체는 단 하나의 책임을 가져야 한다.**
    
    즉, **클래스**나 **모듈**을 **변경할 이유**가 **단 하나** 뿐이어야 한다는 원칙입니다.
    
    **SRP**는 **책임**이라는 개념을 정의하며 **적절한 클래스의 크기**를 제시합니다.
    
    **SRP**는 객체 지향설계에서 중요한 개념이고 이해하고 따르기 쉬운 개념이지만, 프로그래머가 가장 무시하는 규칙입니다. 일반적인 프로그래머는 “**깨끗하고 우아하게 작성된 소프트웨어**"보다 “**동작하기만 하는 소프트웨어**"에 초점을 맞추기 때문입니다.
    
    그렇다면 **SRP**를 이용해서 코드를 개선해보도록 할까요?
    
    아래의 `UserSettings` 클래스는 하나의 클래스가 가지는 **책임**이 여러개가 존재합니다.
    
    1. `changeSettings`: Settings를 변경한다.
    2. `verifyCredentials`: 인증을 검증한다.
    
    ```jsx
    /** SRP Before **/
    class UserSettings {
      constructor(user) { // UserSettings 클래스 생성자
        this.user = user;
      }
    
      changeSettings(userSettings) { // 사용자의 설정을 변경하는 메소드
        if (this.verifyCredentials()) {
          //...
        }
      }
    
      verifyCredentials() { // 사용자의 인증을 검증하는 메소드
        //...
      }
    }
    ```
    
    그렇다면 2가지의 책임을 가지고 있는 `UserSettings` 클래스를 어떻게 분리할 수 있을까요?
    
    1. 사용자의 **설정**을 **변경**하는 **책임**을 가진 `UserSettings` 클래스
    2. 사용자의 **인증**을 **검증**하는 **책임**을 가진 `UserAuth` 클래스
    
    ```jsx
    /** SRP After **/
    class UserAuth {
      constructor(user) { // UserAuth 클래스 생성자
        this.user = user;
      }
    
      verifyCredentials() { // 사용자의 인증을 검증하는 메소드
        //...
      }
    }
    
    class UserSettings {
      constructor(user) { // UserSettings 클래스 생성자
        this.userAuth = new UserAuth(user); // UserAuth를 새로운 객체로 정의한다.
      }
    
      changeSettings(userSettings) { // 사용자의 설정을 변경하는 메소드
        if (this.userAuth.verifyCredentials()) { // 생성자에서 선언한 userAuth 객체의 메소드를 사용한다.
          //...
        }
      }
    }
    ```
    
    <aside>
    🔥 이제 책임을 분리하여 개선된 코드는 클래스마다 **단 1개**의 **책임**을 가지게되었습니다!
    
    </aside>
    
- 3) 개방-폐쇄 원칙 (Open-Closed Principle, **OCP**)
    
    **소프트웨어 엔티티 또는 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**
    
    - 즉, 소프트웨어 개체의 **행위**는 **확장**될 수 있어야 하지만, 개체를 **변경**해서는 **안됩니다.**
    - 조금 더 쉽게 설명하자면, **기존 코드**에 영향을 주지않고 소프트웨어에 **새로운 기능**이나 **구성 요소**를 **추가**할 수 있어야 한다는 것입니다.
    
    만약 요구사항을 **조금** 확장하는 데 소프트웨어를 **엄청나게 수정**해야 한다면, 소모되는 **개발 코스트**또한 **엄청나게 증가**할 것입니다.
    
    그렇다면 **OCP**를 이용해서 코드를 개선해보도록 할까요?
    
    `calculator` 함수는 계산기의 역할을 하는 함수인데요, 현재는 **덧셈**, **뺄셈** 기능만 구현되어 있습니다.
    
    ```jsx
    /** OCP Before **/
    function calculator(nums, option) {
      let result = 0;
      for (const num of nums) {
        if (option === "add") result += num; // option이 add일 경우 덧셈 연산을 합니다.
        else if (option === "sub") result -= num; // option이 sub일 경우 뺄셈 연산을 합니다.
        // 새로운 연산(기능)을 추가 하기 위해서는 함수 내부에서 코드 수정이 필요합니다.
      }
      return result;
    }
    ```
    
    만약 **곱셈**, **나눗셈**, **제곱** 연산 등 다양한 계산기의 **기능**을 추가하려면 `calculator` 함수 내부에서 코드 수정이 필요할 것이고, **OCP** 원칙중에서 **“확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**”에 해당하는 원칙이 깨지게 됩니다.
    
    그렇다면 어떻게 `calculator` 함수를 수정해야 **OCP** 원칙에 위배되지 않고 기능을 추가할 수 있을까요?
    
    `calculator` 함수에서 전달받은 `option`파라미터를 **Callback** 함수로 변경하여 다른 조건이 추가되더라도 실제 `calculator` 함수에서는 어떠한 변화가 발생하지 않도록 구현 할 수 있습니다!
    
    ```jsx
    /** OCP After **/
    function calculator(nums, callBackFunc) { // option을 CallbackFunc로 변경
      let result = 0;
      for (const num of nums) {
        result = callBackFunc(result, num); // option으로 분기하지 않고, Callback함수를 실행하도록 변경
      }
      return result;
    }
    
    const add = (a, b) => a + b; // 함수 변수를 정의합니다.
    const sub = (a, b) => a - b;
    const mul = (a, b) => a * b;
    const div = (a, b) => a / b;
    calculator([2, 5], add); // add 함수 변수를 Callback 함수로 전달합니다.
    ```
    
    <aside>
    🔥 계산기에 어떠한 기능을 추가 하더라도 더이상 `calculator`함수 내부의 코드를 수정하지 않을 수 있게 되었습니다!
    
    </aside>
    
- 4) 리스코프 치환 원칙 (Liskov substitution principle, **LSP**)
    
    **프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.**
    
    여기서 **하위 타입**이란 **`S`** 타입의 객체 **o1** 각각에 대응하는 **`T`** 타입 객체 **o2**가 있고, **`T`** 타입을 이용해서 정의한 모든 프로그램 **`P`**에서 **o2**의 자리에 **o1**을 치환하더라도 **`P`**의 행위가 변하지 않는다면, **`S`**는 **`T`**의 하위 타입입니다.
    
    **즉, `S`가 `T`의 하위 유형이면 해당 프로그램의 속성을 변경하지 않고 `T` 객체를 `S` 객체로 대체할 수 있습니다.**
    
    만약 **부모 클래스**와 **자식 클래스**가 있는 경우 **서로를 바꾸더라도** 해당 프로그램에서 잘못된 결과를 도출하지 않는 것입니다.
    
    그렇다면 **정사각형(Sqaure)**과 **직사각형(Rectagle)** 문제를 이용해서 **LSP**를 적용해보도록 하겠습니다!
    
    **정사각형(Sqaure)**의 특징은 무엇일까요? **높이와 너비가 동일**한 특성을 가지고 있습니다.
    
    정사각형과 다르게 **직사각형(Rectagle)**의 경우 **높이와 너비가 서로 독립적**으로 변경될 수 있는 특성을 가지고 있습니다.
    
    위에서 설명한 각 사각형들의 특성을 가지고 클래스를 구현해보도록 하겠습니다!
    
    ```jsx
    /** LSP Before **/
    class Rectangle {
      constructor(width = 0, height = 0) { // 직사각형의 생성자
        this.width = width;
        this.height = height;
      }
    
      setWidth(width) { // 직사각형은 높이와 너비를 독립적으로 정의한다.
        this.width = width;
        return this;
      }
    
      setHeight(height) { // 직사각형은 높이와 너비를 독립적으로 정의한다.
        this.height = height;
        return this;
      }
    
      getArea() { // 사각형의 높이와 너비의 결과값을 조회하는 메소드
        return this.width * this.height;
      }
    }
    
    class Square extends Rectangle { // 정사각형은 직사각형을 상속받습니다.
      setWidth(width) { // 정사각형은 높이와 너비가 동일하게 정의된다.
        this.width = width;
        this.height = width;
        return this;
      }
    
      setHeight(height) { // 정사각형은 높이와 너비가 동일하게 정의된다.
        this.width = height;
        this.height = height;
        return this;
      }
    }
    
    const rectangleArea = new Rectangle() // 35
      .setWidth(5) // 너비 5
      .setHeight(7) // 높이 7
      .getArea(); // 5 * 7 = 35
    const squareArea = new Square() // 49
      .setWidth(5) // 너비 5
      .setHeight(7) // 높이를 7로 정의하였지만, 정사각형은 높이와 너비를 동일하게 정의합니다.
      .getArea(); // 7 * 7 = 49
    ```
    
    위에 구현한 `Rectangle`과 `Square`클래스에서는 **어떠한 문제**가 있을까요?
    
    `Square`과 `Rectangle`클래스에서 동일한 메소드를 호출하였지만, 다른 결과값이 출력된 것을 확인하였습니다. 만약 **두 클래스**를 서로 **교체**하였을 때에도 **동일한 결과 값**이 **도출되지 않는 것**을 확인 할 수 있겠죠?
    
    위에서 확인한 결과로 **LSP**의 원칙 중에서 [“**부모 클래스와 자식 클래스가 있는 경우 서로를 바꾸더라도 해당 프로그램에서 잘못된 결과를 도출하지 않는 것**”](https://www.notion.so/3-3-12a0622cb99a4f51a9f041f07b378b57)에 해당하는 원칙이 깨치게 된 것을 확인 할 수 있습니다.
    
    그렇다면 어떻게 `Square`과 `Rectangle`클래스를 수정해야 **LSP**원칙에 위배되지 않게 구현할 수 있을까요?
    
    언뜻 보면 `Rectangle`이 `Square`를 포함하고 있는 것 처럼 보이지만 `setWidth`, `setHeigth`메소드처럼 다르게 동작해야하는 경우가 존재하기 때문에 `Square` 클래스는 `Rectangle`을 상속받는 것은 옳은 방법이 아닙니다.
    
    이럴 경우 **두 클래스**를 모두 포함하는 **인터페이스**를 구현해야합니다. 여기서는 `Shape`라는 부모 클래스를 만들어 **인터페이스**의 역할을 대체하도록 만들겠습니다.
    
    ```jsx
    /** LSP After **/
    class Shape { // Rectangle과 Square의 부모 클래스를 정의합니다.
      getArea() { // getArea는 빈 메소드로 정의
      }
    }
    
    class Rectangle extends Shape { // Rectangle은 Shape를 상속받습니다.
      constructor(width = 0, height = 0) { // 직사각형의 생성자
        super();
        this.width = width;
        this.height = height;
      }
    
      getArea() { // 직사각형의 높이와 너비의 결과값을 조회하는 메소드
        return this.width * this.height;
      }
    }
    
    class Square extends Shape { // Square는 Shape를 상속받습니다.
      constructor(length = 0) { // 정사각형의 생성자
        super();
        this.length = length; // 정사각형은 너비와 높이가 같이 깨문에 width와 height 대신 length를 사용합니다.
      }
    
      getArea() { // 정사각형의 높이와 너비의 결과값을 조회하는 메소드
        return this.length * this.length;
      }
    }
    
    const rectangleArea = new Rectangle(7, 7) // 49
      .getArea(); // 7 * 7 = 49
    const squareArea = new Square(7) // 49
      .getArea(); // 7 * 7 = 49
    ```
    
    <aside>
    🔥 `Rectangle`클래스와 `Square`클래스에서 상위 타입의 `getArea` 메소드를 호출하더라도 문제없이 원하는 결과값을 도출할 수 있게 되었습니다!
    
    </aside>
    
- 5) 인터페이스 분리 원칙 (Interface segregation principle, **ISP**)
    
    **특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.**
    
    즉, 클라이언트가 **필요하지 않는 기능**을 가진 **인터페이스**에 의존해서는 안 되고, 최대한 **인터페이스**를 **작게** 유지해야합니다.
    
    조금 더 쉽게 설명하자면, 사용자가 **필요하지 않은 것**들에 **의존하지 않도록**, **인터페이스**를 **작게 유지**해야 한다는 것입니다.
    
    여기서 설명하는 **인터페이스**(`interface`)는 대표적으로 **Java**, **C++** 그리고 **Typescript**에서 사용하는 문법입니다.
    
    **Javascript**에서는 `interface` 기능을 제공하지 않으므로 이번 예제는 **Typescript**로 진행하도록 하겠습니다! 🙂
    
    ```jsx
    /** ISP Before **/
    interface SmartPrinter { // SmartPrinter가 사용할 수 있는 기능들을 정의한 인터페이스 
      print();
    
      fax();
    
      scan();
    }
    
    // SmartPrinter 인터페이스를 상속받은 AllInOnePrinter 클래스
    class AllInOnePrinter implements SmartPrinter {
      print() { // AllInOnePrinter 클래스는 print, fax, scan 기능을 지원한다.
        // ...
      }
    
      fax() { // AllInOnePrinter 클래스는 print, fax, scan 기능을 지원한다.
        // ...
      }
    
      scan() { // AllInOnePrinter 클래스는 print, fax, scan 기능을 지원한다.
        // ...
      }
    }
    
    // SmartPrinter 인터페이스를 상속받은 EconomicPrinter 클래스
    class EconomicPrinter implements SmartPrinter {
      print() { // EconomicPrinter 클래스는 print 기능만 지원한다.
        // ...
      }
    
      fax() { // EconomicPrinter 클래스는 fax 기능을 지원하지 않는다.
        throw new Error('팩스 기능을 지원하지 않습니다.');
      }
    
      scan() { // EconomicPrinter 클래스는 scan 기능을 지원하지 않는다.
        throw new Error('Scan 기능을 지원하지 않습니다.');
      }
    }
    ```
    
    가장 처음 선언된 `SmartPrint` 인터페이스는 `print()`, `fax()`, `scan()` 3가지의 기능을 가지고 있습니다.
    
    `AllInOnePrinter` 클래스는 `print`, `fax`, `scan` 3가지의 기능이 모두 필요하지만, `EconomicPrinter` 클래스의 경우 `print`기능만 지원하는 클래스입니다.
    
    만약 `EconomicPrinter` 클래스에서 `SmarPrinter` 인터페이스를 상속받아 사용할 경우 `fax`, `scan` 2가지의 기능을 **예외 처리**를 해줘야 하는 상황이 발생하게 됩니다.
    
    이후에도 `fax` 기능을 추가로 사용하는 `FacsimilePrinter` 클래스가 `SmartPrinter` 인터페이스를 상속받을 경우 `scan` 기능을 **예외 처리** 해주는 상황이 발생하게 됩니다.
    
    그렇다면 어떻게 `SmartPrinter` 인터페이스를 분리해야 **ISP** 원칙에 위배되지 않고 코드를 구현할 수 있을까요?
    
    `SmartPrinter` 인터페이스에 정의된 기능들을 `Printer`, `Fax`, `Scanner` 인터페이스로 분리하여 **ISP** 원칙에서 “**클라이언트가 필요하지 않는 기능을 가진 인터페이스에 의존해서는 안 되고, 최대한 인터페이스를 작게 유지해야한다.**”에 해당하는 원칙을 수행하는 코드로 개선할 수 있습니다! 🙂
    
    ```jsx
    /** ISP After **/
    interface Printer { // print 기능을 하는 Printer 인터페이스
      print();
    }
    
    interface Fax { // fax 기능을 하는 Fax 인터페이스
      fax();
    }
    
    interface Scanner { // scan 기능을 하는 Scanner 인터페이스
      scan();
    }
    
    // AllInOnePrinter클래스는 print, fax, scan 기능을 지원하는 Printer, Fax, Scanner 인터페이스를 상속받았다.
    class AllInOnePrinter implements Printer, Fax, Scanner {
      print() { // Printer 인터페이스를 상속받아 print 기능을 지원한다.
        // ...
      }
    
      fax() { // Fax 인터페이스를 상속받아 fax 기능을 지원한다.
        // ...
      }
    
      scan() { // Scanner 인터페이스를 상속받아 scan 기능을 지원한다.
        // ...
      }
    }
    
    // EconomicPrinter클래스는 print 기능을 지원하는 Printer 인터페이스를 상속받았다.
    class EconomicPrinter implements Printer {
      print() { // EconomicPrinter 클래스는 print 기능만 지원한다.
        // ...
      }
    }
    
    // FacsimilePrinter클래스는 print, fax 기능을 지원하는 Printer, Fax 인터페이스를 상속받았다.
    class FacsimilePrinter implements Printer, Fax {
      print() { // FacsimilePrinter 클래스는 print, fax 기능을 지원한다.
        // ...
      }
    
      fax() { // FacsimilePrinter 클래스는 print, fax 기능을 지원한다.
        // ...
      }
    }
    ```
    
    <aside>
    🔥 필요없는 인터페이스를 분리하여 **ISP**원칙을 수행하는 코드를 구현할 수 있게 되었습니다.
    
    결국 **불 필요한 짐**을 실은 **인터페이스**에 의존하게 된다면 **예상치도 못한 문제**에 빠질 수 있다는것을 알게 되었습니다!
    
    </aside>
    
- 6) 의존성 역전 원칙 (Dependency Inversion Principle, **DIP**)
    
    **프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.**
    
    **즉**, **높은 계층의 모듈(도메인)이 저수준의 모듈(하부구조)에 의존해서는 안된다.**
    
    조금 더 자세하게 정리해보자면, 
    
    1. **고수준 계층의 모듈**(도메인)은 **저수준 계층의 모듈**(하부구조)에 **의존**해서는 안된다. 둘 다 **추상화에 의존**해야 한다.
    2. 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항은 추상화에 의존해야 한다.
    
    만약 **추상화**를 하지 않고 **고수준 계층의 모듈**이 **저수준 계층의 모듈**을 **의존**하고 있다면 어떤 상황이 발생할까요? **사소한 코드 변경**에도 고수준 계층의 코드를 변경해야할 것이고, 소모되는 **개발 코스트**또한 엄청나게 **증가**할 것입니다.
    
    그렇다면 **DIP**를 이용해서 코드를 개선해보도록 할까요?
    
    `ReportReader`클래스는 파일을 입력받아 확장자별로 파싱하여 **String** 형식으로 변환하는 클래스 입니다.
    
    ```jsx
    /** DIP Before **/
    const readFile = require('fs').readFile;
    
    class XmlFormatter {
      parseXml(content) {
        // Xml 파일을 String 형식으로 변환합니다.
      }
    }
    
    class JsonFormatter {
      parseJson(content) {
        // JSON 파일을 String 형식으로 변환합니다.
      }
    }
    
    class ReportReader {
    
      async read(path) {
        const fileExtension = path.split('.').pop(); // 파일 확장자
    
        if (fileExtension === 'xml') {
          const formatter = new XmlFormatter(); // xml 파일 확장자일 경우 XmlFormatter를 사용한다.
    
          const text = await readFile(path, (err, data) => data);
          return formatter.parseXml(text); // xmlFormatter클래스로 파싱을 할 때 parseXml 메소드를 사용한다.
    
        } else if (fileExtension === 'json') {
          const formatter = new JsonFormatter(); // json 파일 확장자일 경우 JsonFormatter를 사용한다.
    
          const text = await readFile(path, (err, data) => data);
          return formatter.parseJson(text); // JsonFormatter클래스로 파싱을 할 때 parseJson 메소드를 사용한다.
        }
      }
    }
    
    const reader = new ReportReader();
    const report = await reader.read('report.xml');
    // or
    // const report = await reader.read('report.json');
    ```
    
    **Xml** 파일을 파싱하기 위해 `XmlFormatter`클래스를 불러와 `parseXml` 메소드를 호출하고,
    
    **Json** 파일을 파싱하기 위해 `JsonFormatter`클래스를 불러와 `parseJson` 메소드를 호출합니다.
    
    서로 다른 파일 확장자 별로 파싱하는 방법이 달라 **다른 클래스**, **다른 메소드**를 호출하게 되었습니다.
    
    해당 상황을 **구체화에 의존되어 있는 상황**이라고 부르는데요, 그렇다면 어떻게 수정해야 **DIP** 원칙에 맞게끔 코드를 수정할 수 있을까요?
    
    `XmlFormatter`, `JsonFormatter` **클래스**를 동일한 인터페이스, `Formatter` **인터페이스**를 상속받도록 하여 파싱을 위한 `parse` 메소드를 선언하도록 합니다.
    
    그리고 `ReportReader` **클래스**에서 `Formatter` 인터페이스의 `parse` 메소드를 사용하도록 코드를 수정하도록 합니다.
    
    그렇게 한다면 **DIP**원칙인 “**높은 계층의 모듈(도메인)이 저수준의 모듈(하부구조)에 의존해서는 안된다.”**에 해당하는 원칙을 지킬 수 있겠죠?
    
    ```jsx
    /** DIP After **/
    const readFile = require('fs').readFile;
    
    class Formatter { // 인터페이스지만, Javascript로 구현하기 위해 클래스로 선언합니다.
      parse() {  }
    }
    
    class XmlFormatter extends Formatter {
      parse(content) {
        // Xml 파일을 String 형식으로 변환합니다.
      }
    }
    
    class JsonFormatter extends Formatter {
      parse(content) {
        // JSON 파일을 String 형식으로 변환합니다.
      }
    }
    
    class ReportReader {
      constructor(formatter) { // 생성자에서 Formatter 인터페이스를 상속받은 XmlFormatter, JsonFormatter를 전달받습니다.
        this.formatter = formatter;
      }
    
      async read(path) {
        const text = await readFile(path, (err, data) => data);
        return this.formatter.parse(text); // 추상화된 formatter로 데이터를 파싱합니다.
      }
    }
    
    const reader = new ReportReader(new XmlFormatter());
    const report = await reader.read('report.xml');
    // or
    // const reader = new ReportReader(new JsonFormatter());
    // const report = await reader.read('report.json');
    ```
    
    <aside>
    🔥 **DIP** 원칙을 이용하여 **저수준의 모듈**을 수정하더라도 **고수준의 모듈** 코드를 더이상 수정하지 않도록 코드가 개선되었습니다!
    
    </aside>
    

## 04. 쇼핑몰 프로젝트 코드 분리하기

[3.3-4_exported.mp4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/352436f8-fcc1-4d01-beb3-36559e29798b/3.3-4_exported.mp4)

<aside>
🔥 이제 쇼핑몰 프로젝트의 `app.js`에 작성했던 코드를 여러개의 파일로 나눠서 분리시킬 예정인데요,
먼저 이것을 하면 무엇이 좋은지 알아보고 가겠습니다!

</aside>

- 1) 코드를 분리하는게 왜 필요할까요?
    1. **가독성 향상**: 코드를 분리하면서 추상화가 자연스럽게 되기 때문에 코드를 읽기가 훨씬 수월해집니다.
    2. **관리(유지보수)의 용이**: 어떤 함수가 어떤 **역할**을 갖는지 비교적 쉽게 파악할 수 있습니다.
    - **✅ 추상화가 무엇일까요?!**
        
        **추상화**란, 여러분이 작성하는 **함수**랑 비슷하다고 생각하시면 쉽습니다.
        
        여러분이 "**지금 서버와 소켓으로 연결된 모든 클라이언트에 메세지를 보내는 기능**"을 구현하려면 어떻게 할까요?
        
        ```jsx
        // 1. 함수 생성
        function sendMessageAll(message) {
        	// 2. 메세지를 보내기 위한 로직 작성
        	~~~
        	~~
        	~~~~
        }
        ```
        
        위의 코드와 같은 모양으로 기능을 구현하려고 하지 않을까요?
        
        저렇게 단순한 함수로 만든 기능도 "**추상화**"라고 부를수 있습니다!
        
        내가 만든 `sendMessageAll`라는 기능을 사용하는 다른 개발자는 `sendMessageAll` 라는 기능에서 코드가 어떻게 작성됐는지 **굳이 알 필요가 없습니다.**
        
        내가 **socket.io** 라이브러리를 이용해서 기능을 구현했든, 직접 웹소켓을 만들어서 기능을 구현했든 신경쓰지 않아도 되고 **동작**만 하면 되는것이죠.
        
        다른 사람들은 이제 단순히 `sendMessageAll` 라는 **함수**를 호출하면 "**지금 서버와 소켓으로 연결된 모든 클라이언트에 메세지를 보내는 기능**"을 수행하는것만 알고 있을뿐이죠.
        
        <aside>
        🔥 여러분은 지금 **"지금 서버와 소켓으로 연결된 모든 클라이언트에 메세지를 보내는 기능"** 라는 내용을 `sendMessageAll` 라는 **함수** 하나로 **추상화**한것입니다!
        
        </aside>
        
- 2) 어떤 기준으로 코드를 분리하면 좋을까요?
    
    위에서 말했던것중 중요한 키워드가 몇개 있었는데요, 무엇일까요?
    
    - **추상화**
    - **기능(함수)의 역할**
    
    위에 적어놓은 두개의 키워드를 꼽을수 있겠습니다!
    
    그럼, 두개의 키워드를 기준으로 코드를 분리하려면 어떻게 해야할지 고민하면서 바로 코드를 정리해볼게요! (백날 고민하는것보다 실제로 정리된 코드를 보는게 이해가 빠르겠죠!)
    

## 05. 소켓 연결 코드 분리하기

[3.3-5_exported.mp4](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36ecc80b-3819-4de5-80ff-3a63b34c4981/3.3-5_exported.mp4)

<aside>
🔥 앞서 언급한 키워드를 중심으로 코드를 분리해볼게요!

</aside>

- 1) **추상화:** 코드를 이해하기 쉽게 함수로 분리하기
    
    이제 다시 쇼핑몰 프로젝트의 `app.js` 코드로 돌아와서, 아래의 코드를 정리해보도록 하겠습니다!
    
    - 원래 코드
        
        ```jsx
        io.on('connection', (sock) => {
          console.log('새로운 소켓이 연결됐어요!');
        
          sock.on('BUY', (data) => {
            const emitData = {
              ...data,
              date: new Date().toISOString(),
            };
        
            io.emit('BUY_GOODS', emitData);
          });
        
        ... // 생략
        
          sock.on('disconnect', () => {
            console.log(sock.id, '연결이 끊어졌어요!');
          });
        });
        ```
        
    - 정리한 코드
        
        짠! 저는 이렇게 정리해볼게요!
        `on`, `emit` 이런 내용이 있는것보다 이 코드가 무슨 기능을 구현하려는지 파악하기 쉽지 않나요?
        
        ```jsx
        io.on('connection', (sock) => {
          const { watchBuying, watchByebye } = initSocket(sock);
        
          watchBuying();
        
          watchByebye();
        });
        ```
        
        1. 서버에 소켓이 **새로 연결**되면,
        (`io.on('connection', ~~~~`)
        2. 서버에서 소켓 연결할때 필요한 **준비**를 하고,
        (`~~~ = initSocket(sock);`)
        3. **구매를 하는지 감시**하면서
        (`watchBuying();`)
        4. **나가는지 감시**한다.
        (`watchByebye();`)
        
        <aside>
        🔥 **앗 잠깐!**
        `initSocket` 이라는 함수가 없죠? 추상화 된 결과물만 보여드리기 위해 잠깐 숨겨두었어요!
        
        </aside>
        
    - **[코드스니펫] initSocket 코드**
        
        ```jsx
        // app.js
        
        function initSocket(sock) {
          console.log('새로운 소켓이 연결됐어요!');
        
          // 특정 이벤트가 전달됐는지 감지할 때 사용될 함수
          function watchEvent(event, func) {
            sock.on(event, func);
          }
        
          // 연결된 모든 클라이언트에 데이터를 보낼때 사용될 함수
          function notifyEveryone(event, data) {
            io.emit(event, data);
          }
        
          return {
            watchBuying: () => {
              watchEvent('BUY', (data) => {
                const emitData = {
                  ...data,
                  date: new Date().toISOString(),
                };
                notifyEveryone('BUY_GOODS', emitData);
              });
            },
        
            watchByebye: () => {
              watchEvent('disconnect', () => {
                console.log(sock.id, '연결이 끊어졌어요!');
              });
            },
          };
        }
        ```
        
    
    이렇게 코드를 읽기 쉽도록 원래 있던 코드를 분리하면서, 새로운 함수를 만들어 나가는 과정을 "**추상화**"한다고 표현합니다!
    
    이렇게 **추상화** 된 코드는 보통 역할에 맞는 파일에 묶여서 관리되는데요, 바로 해보겠습니다!
    
- 2) **기능의 역할:** 특정 역할을 하는 코드들은 묶어서 파일로 분리할게요!
    
    일단, `initSocket` 함수와 `io.on('connection', ~~~)` 처럼 생긴 소켓 연결과 관련된 코드를 따로 분리해볼까요?
    
    차근차근 따라해주세요!
    
    1. 소켓 관련된 코드만 따로 정리해둘 `socket.js` 파일 만들기
    2. `initSocket` 함수와 `io.on('connection', ~~~)` 처럼 생긴 소켓 연결과 관련된 코드를 `**app.js**` 파일에서 `**socket.js**` 파일로 옮기기
    3. `initSocket` 함수가 `const io = socketIo(http);` 객체를 필요로 하니 이 코드도 그대로 옮깁니다!
    이 코드에서는 **socket.io** 모듈을 사용하기 때문에 해당 모듈을 호출하는 `const socketIo = require('socket.io')` 도 옮깁니다.
    4. `const io = socketIo(http);`에서 **http** 객체도 필요하니 `**app.js**`에서 **http** 객체를 모듈로 내보내줍니다!
    **http** 객체를 내보낼때는 `**app.js**`에서  `module.exports = http` 코드를 통해서 내보냅니다.
    5. **`socket.js`** 파일에서 `**app.js**` 파일이 내보내준 **http** 객체를 가져와서 사용하도록 해줍니다!
    6. 끝일까요? 아쉽게도 아닙니다 😅
    지금처럼 코드를 작성하면 아래와 같은 상황이 벌어집니다!
        - `node app.js` 명령어로 실행해도 서버가 켜지고, `node socket.js` 명령어로 실행해도 서버가 켜집니다!!
        - 단, `**app.js**` 파일으로 실행한 경우 소켓이 전혀 동작하지 않는 상황을 볼 수 있습니다.
        
        🧐 뭔가 이상하죠? 이런 상황이 발생한 이유는 **`socket.js`** 파일이 `**app.js**` 파일을 가져다 사용하고 있는 상황에서 `**app.js**` 파일이 `http.listen` 함수를 실행하여 서버를 켰기 때문인데요,
        어떻게 해결해야 할까요? 다시 차근차근 저를 따라하시면 됩니다!
        
    7. 우선 `**app.js**`파일에서는 서버를 켜지 않도록 `http.listen` 코드를 제거합니다.
    8. **`server.js`** 파일을 생성합니다.
    9. `**server.js**` 파일에서 `**app.js**`와 **`socket.js`** 파일을 참조합니다. 아래처럼요!
        
        ```jsx
        const http = require('./app');
        require('./socket'); // 이렇게 불러오기만 해도 소켓에 연결이 됩니다.
        ```
        
    10. 참조만 하면 안되겠죠? 참조한 **http** 객체를 가지고 서버를 켜주세요!
        
        ```jsx
        http.listen(8080, () => {
          console.log('서버가 요청을 받을 준비가 됐어요');
        });
        ```
        
    
    이제 **`server.js`** 파일을 실행해야만 서버가 켜지며, 서버가 켜질때는 항상 소켓까지 연결 준비가 완료된 상태가 되었습니다!!
    
    전체 코드도 첨부하니, 오류나신다면 참고해보세요!
    
    - server.js
        
        ```jsx
        const http = require("./app");
        require("./socket"); // 이렇게 불러오기만 해도 소켓에 연결이 됩니다.
        
        http.listen(8080, () => {
          console.log("서버가 요청을 받을 준비가 됐어요");
        });
        ```
        
    - socket.js
        
        ```jsx
        const socketIo = require("socket.io");
        const http = require("./app");
        
        const io = socketIo(http);
        
        io.on("connection", (sock) => {
          const {watchBuying, watchByeBye} = initSocket(sock);
        
          watchBuying();
        
          watchByeBye();
        });
        
        function initSocket(sock) {
          console.log("새로운 소켓이 연결됐어요!");
        
          // 특정 이벤트가 전달됐는지 감지할 때 사용될 함수
          function watchEvent(event, func) {
            sock.on(event, func);
          }
        
          // 연결된 모든 클라이언트에 데이터를 보낼때 사용될 함수
          function notifyEveryone(event, func) {
            io.emit(event, func);
          }
        
          return {
            watchBuying: () => {
              watchEvent("BUY", (data) => {
        
                const emitData = {
                  nickname: data.nickname,
                  goodsId: data.goodsId,
                  goodsName: data.goodsName,
                  date: new Date().toISOString(),
                }
        
                notifyEveryone("BUY_GOODS", emitData);
              });
            },
            watchByeBye: () => {
              watchEvent("disconnect", () => {
                console.log(sock.id, "연결이 끊어졌어요!");
              });
            },
          }
        }
        ```
        
    - app.js
        
        ```jsx
        const express = require("express");
        const {Op} = require("sequelize");
        const jwt = require("jsonwebtoken");
        const {Server} = require("http"); // 1. 모듈 불러오기
        const {User, Cart, Goods} = require("./models");
        const authMiddleware = require("./middlewares/auth-middleware");
        
        const app = express();
        const router = express.Router();
        
        const http = Server(app); // 2. express app을 http 서버로 감싸기
        
        app.use(express.static("assets"));
        app.use(express.json());
        
        router.post("/users", async (req, res) => {
          const {nickname, email, password, confirmPassword} = req.body;
        
          if (password !== confirmPassword) {
            res.status(400).send({
              errorMessage: "패스워드가 패스워드 확인란과 동일하지 않습니다.",
            });
            return;
          }
        
          const existUsers = await User.findAll({
            where: {
              [Op.or]: [{nickname}, {email}],
            },
          });
          if (existUsers.length) {
            res.status(400).send({
              errorMessage: "이미 가입된 이메일 또는 닉네임이 있습니다.",
            });
            return;
          }
        
          await User.create({email, nickname, password});
        
          res.status(201).send({message: "회원 가입에 성공하였습니다."});
        });
        
        router.post("/auth", async (req, res) => {
          const {email, password} = req.body;
        
          const user = await User.findOne({where: {email, password}});
        
          if (!user) {
            res.status(400).send({
              errorMessage: "이메일 또는 패스워드가 잘못됐습니다.",
            });
            return;
          }
        
          const token = jwt.sign({userId: user.userId}, "customized-secret-key");
          res.send({
            token,
          });
        });
        
        router.get("/users/me", authMiddleware, async (req, res) => {
          const {user} = res.locals;
          res.send({
            user,
          });
        });
        
        router.get("/goods/cart", authMiddleware, async (req, res) => {
          const {userId} = res.locals.user;
        
          const cart = await Cart.findAll({
            where: {
              userId,
            },
          });
        
          const goodsIds = cart.map((c) => c.goodsId);
        
          const goodsKeyById = await Goods.findAll({
            where: {
              goodsId: goodsIds,
            },
          }).then((goods) =>
            goods.reduce(
              (prev, g) => ({
                ...prev,
                [g.goodsId]: g,
              }),
              {}
            )
          );
        
          res.send({
            cart: cart.map((c) => ({
              quantity: c.quantity,
              goods: goodsKeyById[c.goodsId],
            })),
          });
        });
        
        router.put("/goods/:goodsId/cart", authMiddleware, async (req, res) => {
          const {userId} = res.locals.user;
          const {goodsId} = req.params;
          const {quantity} = req.body;
        
          const existsCart = await Cart.findOne({
            where: {
              userId,
              goodsId,
            },
          });
        
          if (existsCart) {
            existsCart.quantity = quantity;
            await existsCart.save();
          } else {
            await Cart.create({
              userId,
              goodsId,
              quantity,
            });
          }
        
          res.send({});
        });
        
        router.delete("/goods/:goodsId/cart", authMiddleware, async (req, res) => {
          const {userId} = res.locals.user;
          const {goodsId} = req.params;
        
          const existsCart = await Cart.findOne({
            where: {
              userId,
              goodsId,
            },
          });
        
          if (existsCart) {
            await existsCart.destroy();
          }
        
          res.send({});
        });
        
        router.get("/goods", authMiddleware, async (req, res) => {
          const {category} = req.query;
          const goods = await Goods.findAll({
            order: [["goodsId", "DESC"]],
            where: category ? {category} : undefined,
          });
        
          res.send({goods});
        });
        
        router.get("/goods/:goodsId", authMiddleware, async (req, res) => {
          const {goodsId} = req.params;
          const goods = await Goods.findByPk(goodsId);
        
          if (!goods) {
            res.status(404).send({});
          } else {
            res.send({goods});
          }
        });
        
        router.post("/goods", authMiddleware, async (req, res) => {
          const {goodsId, name, thumbnailUrl, category, price} = req.body;
        
          const goods = await Goods.findByPk(goodsId);
          if (goods) {
            return res.status(400).json({success: false, errorMessage: "이미 있는 데이터입니다."});
          }
        
          const createdGoods = await Goods.create({goodsId, name, thumbnailUrl, category, price});
        
          res.status(201).json({goods: createdGoods});
        });
        
        app.use("/api", express.urlencoded({extended: false}), router);
        
        module.exports = http;
        ```
        
    
    또한 **추상화**를 통해 소켓 관련 **코드의 가독성을 높이고**, `app.js` 파일에 있던 소켓과 관련된 모든 코드를 `socket.js` 파일로 분리해서 `app.js` 파일의 가독성까지 높이게 되었습니다! 😆 🎉
    

---

## 06. Quiz

<aside>
❓ SOLID 원칙이란 무엇이고, 각각 어떠한 특성을 가지고 있나요?

</aside>

## 07. Quiz 답안

- `SOLID 원칙이란 무엇이고, 각각 어떠한 특성을 가지고 있나요?` 답안
    
    **SOLID 원칙이란 객체 지향 설계 5원칙을 나타냅니다.**
    
    **단일 책임의 원칙 (Single Responsibility Principle, SRP)**
    
    - **하나의 객체는 단 하나의 책임을 가져야 한다.**
    
    **개방-폐쇄 원칙 (Open-Closed Principle, OCP)**
    
    - **소프트웨어 엔티티 또는 개체(클래스, 모듈, 함수 등)는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.**
    
    **리스코프 치환 원칙 (Liskov substitution principle, LSP)**
    
    - **프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.**
    
    **인터페이스 분리 원칙 (Interface segregation principle, ISP)**
    
    - **특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.**
    
    **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**
    
    - **프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.**